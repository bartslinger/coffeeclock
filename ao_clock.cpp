/*****************************************************************************
* Model: coffeeclock.qm
* File:  ./ao_clock.cpp
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${.::ao_clock.cpp} .......................................................*/
#include "qpn.h"
#include "Arduino.h"
#include "application.h"


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpn version 5.8.0 or higher required
#endif

/*${AOs::Clock} ............................................................*/
/*${AOs::Clock::SM} ........................................................*/
QState Clock_initial(Clock * const me) {
    /* ${AOs::Clock::SM::initial} */
    /* Obtain alarm time from EEPROM */

    //me->alarm_hours = EEPROM.read(0);
    //me->alarm_minutes = EEPROM.read(1);
    me->alarm_hours = 0U;
    me->alarm_minutes = 0U;

    /* Make sure it is within bounds */
    if (me->alarm_hours > 23) me->alarm_hours = 23;
    if (me->alarm_minutes > 59) me->alarm_minutes = 59;

    /* Set initial time */
    me->time_hours = 12U;
    me->time_minutes = 0U;
    return Q_TRAN(&Clock_off);
}
/*${AOs::Clock::SM::on} ....................................................*/
QState Clock_on(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::SET_TIME} */
        case SET_TIME_SIG: {
            uint32_t param = Q_PAR(me);

            uint8_t minutes = param;
            uint8_t hours   = param >> 8;

            me->time_minutes = minutes;
            me->time_hours = hours;
            QACTIVE_POST_X((QActive *)&AO_Clock, 1U, TIME_UPDATED_SIG, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::COMPUTER_DISCONNECTED} */
        case COMPUTER_DISCONNECTED_SIG: {
            status_ = Q_TRAN(&Clock_disconnected);
            break;
        }
        /* ${AOs::Clock::SM::on::TURN_OFF} */
        case TURN_OFF_SIG: {
            status_ = Q_TRAN(&Clock_off);
            break;
        }
        /* ${AOs::Clock::SM::on::ALARM_SET_FROM_COMPUTER} */
        case ALARM_SET_FROM_COMPUTER_SIG: {
            uint32_t param = Q_PAR(me);

            uint8_t minutes = param;
            uint8_t hours   = param >> 8;

            me->alarm_minutes = minutes;
            me->alarm_hours = hours;
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::alarm} .............................................*/
QState Clock_alarm(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::alarm} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_ALARM, HIGH);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm} */
        case Q_EXIT_SIG: {
            digitalWrite(LED_ALARM, LOW);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_on);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::alarm::set_minutes} ................................*/
QState Clock_set_minutes(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::alarm::set_minutes} */
        case Q_EXIT_SIG: {
            BSP_displayTime(me->alarm_hours, me->alarm_minutes);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_minutes::ROTARY_PUSH} */
        case ROTARY_PUSH_SIG: {
            status_ = Q_TRAN(&Clock_show_alarm);
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_minutes::ROTARY_INC} */
        case ROTARY_INC_SIG: {
            me->alarm_minutes++;
            if (me->alarm_minutes > 59) {
                me->alarm_minutes = 0;
            }
            status_ = Q_TRAN(&Clock_minutes_blink_on);
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_minutes::ROTARY_DEC} */
        case ROTARY_DEC_SIG: {
            me->alarm_minutes--;
            if (me->alarm_minutes > 59) {
                me->alarm_minutes = 59;
            }
            status_ = Q_TRAN(&Clock_minutes_blink_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_alarm);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::alarm::set_minutes::minutes_blink_on} ..............*/
QState Clock_minutes_blink_on(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::alarm::set_minutes::minutes_blink_on} */
        case Q_ENTRY_SIG: {
            QActive_armX(&me->super, 0U, ALARM_SET_BLINK_TIME, 0U);
            BSP_displayTime(me->alarm_hours, me->alarm_minutes);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_minutes::minutes_blink_on} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_minutes::minutes_blink_on::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Clock_minutes_blink_off);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_set_minutes);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::alarm::set_minutes::minutes_blink_off} .............*/
QState Clock_minutes_blink_off(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::alarm::set_minutes::minutes_blink_off} */
        case Q_ENTRY_SIG: {
            QActive_armX(&me->super, 0U, ALARM_SET_BLINK_TIME, 0U);
            BSP_displayHideMinutes();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_minutes::minutes_blink_off} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_minutes::minutes_blink_of~::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Clock_minutes_blink_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_set_minutes);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::alarm::show_alarm} .................................*/
QState Clock_show_alarm(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::alarm::show_alarm} */
        case Q_ENTRY_SIG: {
            QActive_armX(&me->super, 0U, BSP_TICKS_PER_SEC*0.5, 0U);

            uint32_t param = (me->alarm_hours << 8) | (me->alarm_minutes);
            /* Save alarm time in EEPROM */
            QACTIVE_POST_X((QActive *)&AO_Computer, 1U, ALARM_SET_SIG, param);
            //EEPROM.write(0, me->alarm_hours);
            //EEPROM.write(1, me->alarm_minutes);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::show_alarm} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::show_alarm::ROTARY_PUSH} */
        case ROTARY_PUSH_SIG: {
            status_ = Q_TRAN(&Clock_time);
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::show_alarm::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Clock_time);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_alarm);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::alarm::set_hours} ..................................*/
QState Clock_set_hours(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::alarm::set_hours} */
        case Q_EXIT_SIG: {
            BSP_displayTime(me->alarm_hours, me->alarm_minutes);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_hours::ROTARY_INC} */
        case ROTARY_INC_SIG: {
            me->alarm_hours++;
            if (me->alarm_hours > 23) {
                me->alarm_hours = 0;
            }
            status_ = Q_TRAN(&Clock_hours_blink_on);
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_hours::ROTARY_DEC} */
        case ROTARY_DEC_SIG: {
            me->alarm_hours--;
            if (me->alarm_hours > 23) {
                me->alarm_hours = 23;
            }
            status_ = Q_TRAN(&Clock_hours_blink_on);
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_hours::ROTARY_PUSH} */
        case ROTARY_PUSH_SIG: {
            status_ = Q_TRAN(&Clock_minutes_blink_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_alarm);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::alarm::set_hours::hours_blink_on} ..................*/
QState Clock_hours_blink_on(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::alarm::set_hours::hours_blink_on} */
        case Q_ENTRY_SIG: {
            QActive_armX(&me->super, 0U, ALARM_SET_BLINK_TIME, 0U);
            BSP_displayTime(me->alarm_hours, me->alarm_minutes);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_hours::hours_blink_on} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_hours::hours_blink_on::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Clock_hours_blink_off);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_set_hours);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::alarm::set_hours::hours_blink_off} .................*/
QState Clock_hours_blink_off(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::alarm::set_hours::hours_blink_off} */
        case Q_ENTRY_SIG: {
            QActive_armX(&me->super, 0U, ALARM_SET_BLINK_TIME, 0U);
            BSP_displayHideHours();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_hours::hours_blink_off} */
        case Q_EXIT_SIG: {
            QActive_disarmX(&me->super, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::alarm::set_hours::hours_blink_off::Q_TIMEOUT} */
        case Q_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Clock_hours_blink_on);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_set_hours);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::time} ..............................................*/
QState Clock_time(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::time} */
        case Q_ENTRY_SIG: {
            digitalWrite(LED_TIME, HIGH);
            BSP_displayTime(me->time_hours, me->time_minutes);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::time} */
        case Q_EXIT_SIG: {
            digitalWrite(LED_TIME, LOW);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::time::ROTARY_PUSH} */
        case ROTARY_PUSH_SIG: {
            status_ = Q_TRAN(&Clock_hours_blink_on);
            break;
        }
        /* ${AOs::Clock::SM::on::time::TIME_UPDATED} */
        case TIME_UPDATED_SIG: {
            BSP_displayTime(me->time_hours, me->time_minutes);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_on);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::on::disconnected} ......................................*/
QState Clock_disconnected(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::on::disconnected} */
        case Q_ENTRY_SIG: {
            BSP_displayDashes();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::on::disconnected::TIME_UPDATED} */
        case TIME_UPDATED_SIG: {
            status_ = Q_TRAN(&Clock_time);
            break;
        }
        default: {
            status_ = Q_SUPER(&Clock_on);
            break;
        }
    }
    return status_;
}
/*${AOs::Clock::SM::off} ...................................................*/
QState Clock_off(Clock * const me) {
    QState status_;
    switch (Q_SIG(me)) {
        /* ${AOs::Clock::SM::off} */
        case Q_ENTRY_SIG: {
            BSP_displayOff();
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Clock::SM::off::TURN_ON} */
        case TURN_ON_SIG: {
            status_ = Q_TRAN(&Clock_disconnected);
            break;
        }
        /* ${AOs::Clock::SM::off::TURN_OFF} */
        case TURN_OFF_SIG: {
            //uint16_t param = Q_PAR(me);
            //BSP_checkLdrValue(param);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

